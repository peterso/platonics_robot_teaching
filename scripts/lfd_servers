#!/usr/bin/env python3
import rospy
import actionlib
from lfd import LfD

from skills_manager.msg import LfdRecordAction, LfdRecordGoal, LfdRecordResult, LfdRecordFeedback
from skills_manager.msg import LfdExecuteAction, LfdExecuteGoal, LfdExecuteResult, LfdExecuteFeedback
from skills_manager.msg import LfdExecuteSequenceAction, LfdExecuteSequenceGoal, LfdExecuteSequenceResult, LfdExecuteSequenceFeedback
from skills_manager.msg import LfdHomeAction, LfdHomeGoal, LfdHomeResult, LfdHomeFeedback
from skills_manager.msg import AbortGripperAction, AbortGripperGoal, AbortGripperResult, AbortGripperFeedback
from skills_manager.srv import ListTrajectories, ListTrajectoriesRequest, ListTrajectoriesResponse
from platonics_vision.srv import IterativeRegistrationLocalizer, IterativeRegistrationLocalizerRequest, IterativeRegistrationLocalizerResponse

from panda_ros.pose_transform_functions import pose_2_transformation


class LfDServer():
    def __init__(self):
        rospy.init_node("learning_node")
        self._lfd = LfD()
        self.establish_ros_connections()

    def establish_ros_connections(self):
        self._record_action_server = actionlib.SimpleActionServer(
            'lfdRecord', LfdRecordAction, self.execute_record, auto_start=False
        )
        self._record_action_server.start()
        self._execute_action_server = actionlib.SimpleActionServer(
            'lfdExecute', LfdExecuteAction, self.execute_execute, auto_start=False
        )
        self._execute_action_server.start()
        self._execute_sequence_action_server = actionlib.SimpleActionServer(
            'lfdExecuteSequence', LfdExecuteSequenceAction, self.execute_execute_sequence, auto_start=False
        )
        self._execute_sequence_action_server.start()
        self._home_action_server = actionlib.SimpleActionServer(
            'lfdHome', LfdHomeAction, self.execute_home, auto_start=False
        )
        self._home_action_server.start()
        rospy.Service("list_trajectories", ListTrajectories, self.handle_list_trajectories)
        rospy.wait_for_service('iterative_sift_localizer')
        self.iterative_localizer = rospy.ServiceProxy('iterative_sift_localizer', IterativeRegistrationLocalizer)

        self._open_gripper_action_server = actionlib.SimpleActionServer(
            'abort_gripper', AbortGripperAction, self.execute_open_gripper, auto_start=False
        )
        self._open_gripper_action_server.start()



    def handle_list_trajectories(self, request: ListTrajectoriesRequest):
        response = ListTrajectoriesResponse()
        response.trajectories = self._lfd.list_all_available_trajectories()
        return response

    def execute_open_gripper(self, goal: AbortGripperGoal):
        self._lfd.robot.stop_gripper()
        self._lfd.robot.home_gripper()
        result = AbortGripperResult()
        result.success = True
        self._open_gripper_action_server.set_succeeded(result)

    def execute_execute(self, goal: LfdExecuteGoal):
        rospy.loginfo("Received request")
        if goal.localize_box:
            request = IterativeRegistrationLocalizerRequest()
            request.steps.data = 1
            request.template_file_name = goal.template_file_name
            resp: IterativeRegistrationLocalizerResponse = self.iterative_localizer(request)
            self._lfd.localization_transform = pose_2_transformation(resp.pose)
        self._lfd.buttons.start_listening()
        self._lfd.buttons.start_listening()
        self._lfd.load(goal.skill_name)
        self._lfd.execute()
        self._lfd.save(goal.skill_name)
        self._lfd.buttons.stop_listening()
        result = LfdExecuteResult()
        result.success = True
        self._execute_action_server.set_succeeded(result)


    def execute_execute_sequence(self, goal: LfdExecuteSequenceGoal):
        rospy.loginfo("Received request")
        feedback = LfdExecuteSequenceFeedback()
        result = LfdExecuteSequenceResult()
        result.success = True
        if goal.localize_box:
            request = IterativeRegistrationLocalizerRequest()
            request.steps.data = 5
            request.template_file_name = goal.template_file_name
            resp: IterativeRegistrationLocalizerResponse = self.iterative_localizer(request)
            self._lfd.localization_transform = pose_2_transformation(resp.pose)
        aborting = False
        for skill_name in goal.skill_names:
            if aborting:
                self._lfd.execute_end()
                break
            feedback.skill_name = skill_name
            self._lfd.buttons.start_listening()
            self._lfd.load(skill_name)
            self._lfd.execute_start()
            retry_insertion_flag = 0
            while not(self._lfd.buttons.end):
                end_execute = self._lfd.execute_step(retry_insertion_flag)
                if self._execute_sequence_action_server.is_preempt_requested():
                    result.success = False
                    end_execute = True
                    aborting = True
                    self._execute_sequence_action_server.set_preempted(result)
                if end_execute:
                    break
                feedback.camera_feedback = self._lfd.data['recorded_img_feedback_flag'][self._lfd.time_index]
                feedback.spiraling = self._lfd.data['recorded_spiral_flag'][self._lfd.time_index]
                feedback.gripper = self._lfd.gripper_state
                feedback.waypoint_index = self._lfd.time_index
                self._execute_sequence_action_server.publish_feedback(feedback)
            self._lfd.execute_end()
            self._lfd.save(skill_name)
        if result.success:
            self._execute_sequence_action_server.set_succeeded(result)
        if aborting:
            self._lfd.abort()


    def execute_record(self, goal: LfdRecordGoal):
        self._lfd.init_record(trigger=0.005)
        feedback = LfdRecordFeedback()
        while not self._lfd.buttons.end:
            self._lfd.record_step()
            feedback.trajectory_length = len(self._lfd.recorded_pose)
            feedback.camera_feedback = self._lfd.buttons.img_feedback_flag
            feedback.paused = self._lfd.buttons.pause
            feedback.spiraling = self._lfd.buttons.spiral_flag
            feedback.stiffness = self._lfd.buttons.stiff_rotation
            feedback.gripper = self._lfd.gripper_state
            self._record_action_server.publish_feedback(feedback)
        self._lfd.end_record()
        self._lfd.save(goal.skill_name)
        result = LfdRecordResult()
        result.success = True
        self._record_action_server.set_succeeded(result)

    def execute_home(self, goal: LfdHomeGoal):
        self._lfd.robot.home(
            height=goal.height,
            front_offset=goal.front,
            side_offset=goal.side,
        )
        self._lfd.robot.offset_compensator(10)
        result = LfdHomeResult()
        result.success = True
        self._home_action_server.set_succeeded(result)

    def run(self):
        while not rospy.is_shutdown():
            self._lfd.rate.sleep()

if __name__ == "__main__":
    node = LfDServer()
    try:
        node.run()
    except rospy.ROSInterruptException:
        pass

